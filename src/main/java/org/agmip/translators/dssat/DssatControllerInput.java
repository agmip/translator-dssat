package org.agmip.translators.dssat;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import org.agmip.common.Functions;
import org.agmip.core.types.TranslatorInput;
import static org.agmip.translators.dssat.DssatCommonInput.*;
import static org.agmip.util.MapUtil.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author Meng Zhang
 */
public class DssatControllerInput implements TranslatorInput {

    private final DssatXFileInput mgnReader = new DssatXFileInput();
    private final DssatSoilInput soilReader = new DssatSoilInput();
    private final DssatWeatherInput wthReader = new DssatWeatherInput();
    private final DssatAFileInput obvAReader = new DssatAFileInput();
    private final DssatTFileInput obvTReader = new DssatTFileInput();
    private final DssatCulFileInput culReader = new DssatCulFileInput();
    private static final Logger LOG = LoggerFactory.getLogger(DssatControllerInput.class);

    /**
     * All DSSAT Data input method, used for single file or zip package
     *
     * @param arg0 The path of input experiment file
     * @return result data holder object
     */
    @Override
    public HashMap readFile(String arg0) {
        HashMap brMap;
        try {
            brMap = getBufferReader(arg0);
        } catch (FileNotFoundException fe) {
            LOG.warn("File not found under following path : [" + arg0 + "]!");
            return new HashMap();
        } catch (IOException e) {
            LOG.error(Functions.getStackTrace(e));
            return new HashMap();
        }
        return read(brMap);
    }
    
    /**
     * All DSSAT Data input method, used for uncompressed multiple files
     *
     * @param files The list of model input files for translation
     * @return result data holder object
     */
    public HashMap readFile(List<File> files) {
        HashMap brMap;
        try {
            brMap = getBufferReader(files);
        } catch (IOException e) {
            LOG.error(Functions.getStackTrace(e));
            return new HashMap();
        }
        return read(brMap);
    }
    
    /**
     * All DSSAT Data input method, specially used for DSSAT files generated by CRAFT
     *
     * @param arg0 The path of CRAFT working folder
     * @return result data holder object
     */
    public HashMap readFileFromCRAFT(String arg0) {
        HashMap brMap;
        try {
            File dir = new File(arg0);

            // Data frin CRAFT with DSSAT format
            if (dir.isDirectory()) {
                List<File> files = new ArrayList();
                for (File f : dir.listFiles()) {
                    String name = f.getName().toUpperCase();
                    // XFile folder
                    if (name.equals("FILEX")) {
                        for (File exp : f.listFiles()) {
                            if (exp.isFile()) {
                                String expName = exp.getName().toUpperCase();
                                if (expName.matches(".+\\.\\w{2}X")) {
                                    files.add(exp);
                                }
                            }
                        }
                    } // Weather folder
                    else if (name.equals("WEATHER")) {
                        for (File wth : f.listFiles()) {
                            if (wth.isFile()) {
                                String wthName = wth.getName().toUpperCase();
                                if (wthName.endsWith(".WTH")) {
                                    files.add(wth);
                                }

                            }
                        }
                    } // Soil file
                    else if (f.isFile() && name.endsWith(".SOL")) {
                        files.add(f);
                    }
                }
                brMap = getBufferReader(files);
            } else {
                LOG.error("You need to provide the CRAFT working folder used for generating DSSAT files.");
                return new HashMap();
            }
        } catch (IOException e) {
            LOG.error(Functions.getStackTrace(e));
            return new HashMap();
        }
        return read(brMap);
    }
    
    private HashMap read(HashMap brMap) {

        HashMap ret = new HashMap();
        HashMap metaData = new HashMap();
        ArrayList<HashMap> expArr = new ArrayList<HashMap>();
        HashMap expData;
        ArrayList<HashMap> mgnArr;
        ArrayList<HashMap> soilArr;
        HashMap soilData;
        HashMap soilTmpMap = new HashMap();
        HashMap<String, String> soilAnalysisMap = new HashMap();
        String soilId;
        ArrayList<HashMap> wthArr;
        HashMap wthData;
        HashMap wthTmpMap = new HashMap();
        String wthId;
        HashMap obvAFiles;
        HashMap obvAFile;
        ArrayList<HashMap> obvAArr;
        HashMap obvTFiles;
        HashMap obvTFile;
        ArrayList<HashMap> obvTArr;
        ArrayList<HashMap> culArr;
        HashMap culData;

        try {

            // Set Data source and version info
            setDataVersionInfo(metaData);

            // Try to read XFile (treatment; management)
            mgnArr = mgnReader.readTreatments(brMap, metaData);

            // Try to read soil File
            soilArr = soilReader.readSoilSites(brMap, metaData);

            // Try to read weather File
            wthArr = wthReader.readDailyData(brMap, metaData);

            // Try to read Observed AFile (summary data)
            obvAFiles = obvAReader.readObvData(brMap);

            // Try to read Observed AFile (time-series data)
            obvTFiles = obvTReader.readObvData(brMap);

            // Try to read cultivar File
            culArr = culReader.readCultivarData(brMap, metaData);

        } catch (FileNotFoundException fe) {
            LOG.warn(Functions.getStackTrace(fe));
            return ret;
        } catch (IOException e) {
            LOG.error(Functions.getStackTrace(e));
            return ret;
        }

        // Combine the each part of data
        for (int i = 0; i < mgnArr.size(); i++) {

            // Set meta data block for this treatment
            expData = mgnReader.setupMetaData(metaData, i);

            // Set soil data for this treatment
            wthId = getValueOr(expData, "wst_id", "0");
            if (!wthId.equals("0")) {
                wthData = getSectionDataWithNocopy(wthArr, "wst_id", wthId);
                if (wthData != null && !wthData.isEmpty()) {
//                    expData.put(wthReader.jsonKey, wthData);
                    wthTmpMap.put(wthId, wthData);
                } else {
                    wthId = getValueOr(expData, "dssat_wst_id", "0");
                    wthData = getSectionDataWithNocopy(wthArr, "wst_id", wthId);
                    if (wthData != null && !wthData.isEmpty()) {
                        wthTmpMap.put(wthId, wthData);
                        expData.put("wst_id", wthId);
                    }
                }
            }

            // Set weather data for this treatment
            soilId = getValueOr(expData, "soil_id", "0");
            if (!soilId.equals("0") && !soilTmpMap.containsKey(soilId)) {
                soilData = getSectionDataWithNocopy(soilArr, "soil_id", soilId);
                // if there is soil analysis data, create new soil block by using soil analysis info
                if (expData.get("soil_analysis") != null) {
                    HashMap saTmp = (HashMap) expData.remove("soil_analysis");
                    String saHash = saTmp.hashCode() + "_" + soilId;
                    if (!soilAnalysisMap.containsKey(saHash)) {
                        if (soilData == null) {
                            soilData = new HashMap();
                        } else {
                            soilData = CopyList(soilData);
                        }

                        // Update soil site data
                        copyItem(soilData, saTmp, "sadat");
                        copyItem(soilData, saTmp, "smhb");
                        copyItem(soilData, saTmp, "smpx");
                        copyItem(soilData, saTmp, "smke");
                        soilId += "_" + (i + 1);
                        soilData.put("soil_id", soilId);
                        expData.put("soil_id", soilId);
                        soilAnalysisMap.put(saHash, soilId);

                        // Update soil layer data
                        ArrayList<HashMap> soilLyrs = getObjectOr(soilData, soilReader.layerKey, new ArrayList());
                        ArrayList<HashMap> saLyrs = getObjectOr(saTmp, mgnReader.icEventKey, new ArrayList());
                        String[] copyKeys = {"sllb", "slbdm", "sloc", "slni", "slphw", "slphb", "slpx", "slke", "slsc"};
                        soilData.put(soilReader.layerKey, combinLayers(soilLyrs, saLyrs, "sllb", "sllb", copyKeys));
                    } else {
                        expData.put("soil_id", soilAnalysisMap.get(saHash));
                        soilData = null;
                    }
                }

                if (soilData != null && !soilData.isEmpty()) {
//                    expData.put(soilReader.jsonKey, soilData);
                    soilTmpMap.put(soilId, soilData);
                }
            }

            // Get exname
            String exname = (String) expData.remove("exname_o");
            if (exname == null) {
                exname = "";
            }
            // observed data (summary)
            obvAFile = getObjectOr(obvAFiles, exname, new HashMap());
            obvAArr = getObjectOr(obvAFile, obvAReader.obvDataKey, new ArrayList<HashMap>());
            HashMap obv = new HashMap();
            expData.put(obvAReader.jsonKey, obv);
            if (!getValueOr(expData, "trno", "0").equals("0")) {
                HashMap tmp = getSectionDataWithNocopy(obvAArr, "trno_a", expData.get("trno").toString());
                if (tmp != null) {
                    obv.putAll(tmp);
                }
            }

            // observed data (time-series)
            obvTFile = getObjectOr(obvTFiles, exname, new HashMap());
            obvTArr = getObjectOr(obvTFile, obvTReader.obvDataKey, new ArrayList<HashMap>());
            if (!getValueOr(expData, "trno", "0").equals("0")) {
                HashMap tmp = getSectionDataWithNocopy(obvTArr, "trno_t", expData.get("trno").toString());
                if (tmp != null) {
                    obv.put("timeSeries", tmp.get(obvTReader.obvDataKey));
                }
            }

            // there is no observed data, remove the key from experiment object
            if (obv.isEmpty()) {
                expData.remove(obvAReader.jsonKey);
            }

            // Set experiment data include management, Initial Condition and DSSAT specific data blocks for this treatment
            mgnReader.setupTrnData(expData, mgnArr.get(i), obvAFiles, obvTFiles);

            // Set dssat cultivar info block
            if (!culArr.isEmpty()) {
                HashMap mgnData = getObjectOr(expData, mgnReader.jsonKey, new HashMap());
                ArrayList<HashMap> eventArr = getObjectOr(mgnData, "events", new ArrayList());
                ArrayList<HashMap> culTmpArr = new ArrayList<HashMap>();
                for (int j = 0; j < eventArr.size(); j++) {
                    if (getObjectOr(eventArr.get(j), "event", "").equals("planting")) {
                        culData = getSectionDataWithNocopy(culArr, "cul_id", (String) eventArr.get(j).get("cul_id"));
                        if (culData != null) {
                            culTmpArr.add(culData);
                        }
                    }
                }

                if (!culTmpArr.isEmpty()) {
                    HashMap tmp = new HashMap();
                    tmp.put(culReader.dataKey, culTmpArr);
                    expData.put(culReader.jsonKey, tmp);
                }
            }

            // Add to output array
            expArr.add(expData);
        }

        if (!expArr.isEmpty()) {
            ret.put("experiments", expArr);
        
            if (!soilTmpMap.isEmpty()) {
                ret.put("soils", new ArrayList(soilTmpMap.values()));
            }
            if (!wthTmpMap.isEmpty()) {
                ret.put("weathers", new ArrayList(wthTmpMap.values()));
            }
        } else {
            // If only weather data or soil data
            if (!soilArr.isEmpty()) {
                ret.put("soils", soilArr);
            }
            if (!wthArr.isEmpty()) {
                ret.put("weathers", wthArr);
            }
        }

        return ret;
    }
}
